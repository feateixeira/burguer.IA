# Corre√ß√µes de Seguran√ßa - Autentica√ß√£o Admin

## Problema Identificado

A autentica√ß√£o de senha administrativa estava sendo feita **completamente no lado do cliente**, usando `bcryptjs` diretamente no navegador. Isso permitia que atacantes:

1. **Manipulassem o sessionStorage** para falsificar autentica√ß√£o
2. **Modificassem o c√≥digo cliente** para bypassar verifica√ß√µes
3. **Interceptassem o hash da senha** durante transfer√™ncia
4. **Criassem hashes v√°lidos** localmente

## Solu√ß√£o Implementada

### 1. Edge Function: `verify-admin-password`

Nova Edge Function que processa toda autentica√ß√£o **server-side**:

```typescript
// Cliente nunca recebe o hash
const { data } = await supabase.functions.invoke('verify-admin-password', {
  body: { password }
});
```

**Caracter√≠sticas de Seguran√ßa:**
- Hash **nunca** √© transferido para o cliente
- Verifica√ß√£o acontece **exclusivamente no servidor**
- Usu√°rio deve estar autenticado (Supabase Auth)
- Apenas o estabelecimento do usu√°rio √© verificado
- Retorna apenas `{ valid: boolean, sessionTimeout: number }`

### 2. RPC Function: `check_admin_password_exists`

Fun√ß√£o PostgreSQL que verifica se senha existe **sem expor o hash**:

```sql
SELECT check_admin_password_exists(establishment_uuid);
-- Retorna: true/false (nunca o hash)
```

**Benef√≠cios:**
- Cliente verifica se senha est√° configurada sem receber o hash
- Reduz transfer√™ncia desnecess√°ria de dados sens√≠veis
- Permite valida√ß√£o no cliente antes de mostrar UI de senha

### 3. Modifica√ß√µes no Cliente

#### `src/hooks/useAdminAuth.tsx`

**ANTES (INSEGURO):**
```typescript
import bcrypt from 'bcryptjs';

// Hash exposto ao cliente! ‚ùå
const { data: establishment } = await supabase
  .from('establishments')
  .select('admin_password_hash, settings')
  .single();

// Compara√ß√£o no cliente! ‚ùå
const isValid = await bcrypt.compare(password, establishment.admin_password_hash);
```

**DEPOIS (SEGURO):**
```typescript
// Apenas verifica exist√™ncia sem expor hash ‚úÖ
const { data: hasPassword } = await supabase
  .rpc('check_admin_password_exists', { establishment_uuid });

// Autentica√ß√£o 100% server-side ‚úÖ
const { data } = await supabase.functions.invoke('verify-admin-password', {
  body: { password }
});
```

#### `src/components/AdminPasswordConfig.tsx`

**ANTES (INSEGURO):**
```typescript
// Hash exposto para verifica√ß√£o! ‚ùå
const { data: verifyData } = await supabase.functions.invoke('hash-admin-password', {
  body: {
    action: 'verify',
    password: currentPassword,
    currentHash: currentSettings!.admin_password_hash, // ‚ùå Hash no cliente!
  },
});
```

**DEPOIS (SEGURO):**
```typescript
// Verifica√ß√£o sem expor hash ‚úÖ
const { data: verifyData } = await supabase.functions.invoke('verify-admin-password', {
  body: { password: currentPassword } // Apenas senha em texto claro
});
```

## Garantias de Seguran√ßa

‚úÖ **Hash nunca √© transferido para o cliente**
‚úÖ **Toda compara√ß√£o acontece server-side**
‚úÖ **Cliente s√≥ recebe resultado booleano (v√°lido/inv√°lido)**
‚úÖ **Atacante n√£o pode manipular sessionStorage para bypass**
‚úÖ **C√≥digo cliente modificado n√£o bypassa autentica√ß√£o**
‚úÖ **Senha em texto claro s√≥ √© enviada via HTTPS para Edge Function**

## Migrations Necess√°rias

Execute no Supabase SQL Editor:

1. `supabase/migrations/20250103000000_add_check_admin_password_rpc.sql` - RPC function para verificar exist√™ncia
2. Edge Function `verify-admin-password` j√° est√° criada em `supabase/functions/verify-admin-password/`

## Como Funciona Agora (Fluxo Seguro)

1. **Usu√°rio digita senha de 4 d√≠gitos** no cliente
2. **Cliente envia apenas a senha** (texto claro) para Edge Function via HTTPS
3. **Edge Function autentica o usu√°rio** via Supabase Auth
4. **Edge Function busca hash do banco** (nunca exposto ao cliente)
5. **Edge Function compara senha com hash** usando bcrypt server-side
6. **Edge Function retorna apenas** `{ valid: boolean, sessionTimeout: number }`
7. **Cliente armazena apenas flag booleana** no sessionStorage
8. **Flag expira ap√≥s timeout** configurado

## Testes de Seguran√ßa Recomendados

1. ‚úÖ Tentar manipular `sessionStorage.setItem('admin_auth', 'true')` - Deve falhar
2. ‚úÖ Tentar interceptar hash via DevTools - N√£o deve aparecer
3. ‚úÖ Tentar modificar c√≥digo cliente para bypass - Deve falhar (Edge Function valida)
4. ‚úÖ Tentar reverter mudan√ßas e usar bcrypt no cliente - Deve ser detectado em code review

## Notas Importantes

‚ö†Ô∏è **A senha ainda √© enviada em texto claro** do cliente para a Edge Function. Isso √© aceit√°vel porque:
- A transfer√™ncia acontece via HTTPS (criptografada)
- A senha √© de apenas 4 d√≠gitos (PIN, n√£o senha completa)
- O hash nunca √© exposto, ent√£o mesmo interceptando a senha, n√£o h√° como criar hashes v√°lidos

üîí **Para m√°xima seguran√ßa**, considere:
- Usar senha mais longa (8+ d√≠gitos) em produ√ß√£o
- Implementar rate limiting na Edge Function
- Adicionar 2FA para a√ß√µes cr√≠ticas
- Implementar logout autom√°tico ap√≥s inatividade

